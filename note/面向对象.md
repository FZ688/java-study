# 面向对象

## 1.面向对象基础

i.**开发一个个对象，把数据交给对象，再调用对象的方法来完成对数据的处理**
ii.对象本质上是一种特殊的**数据结构**
iii. class也就是**类**，是对象的设计图（模板）

  ```java
  public class 类名(){
      1.变量，用来说明对象可以处理什么数据
      2.方法，描述对象有什么功能，也就是可以对数据进行什么样的处理
         ...
  }
  ```

有了类就可以创建出对象

```java
类名 对象名 = new 类名();
```

------------------------------------------------------------------------------------------------------

```java
public class Test {
    public static void main(String[] args) {
        //1.创建学生对象
        Student s1 = new Student();
        s1.name ="FZ";
        s1.chinese=150;
        s1.math = 150;
        s1.printScore();
        s1.AvergeScore();
        //2.再创建一个学生对象
        Student s2 =new Student();
        s2.name ="FZ01";
        s2.math=150;
        s2.chinese=150;
        s2.printScore();
        s2.AvergeScore();

    }
}
```

s1里存着对象的地址

s1指向new出来的对象的地址，new出来的对象里面有类的的地址，类的地址指向 Student.class

## 2.识别引用类型的变量

* ``Student s1 = new Student();``

因为s1变量中存储的是对象的地址，因此变量s1也称为引用类型的变量

## 3.注意事项

i.类中定义的变量是**成员变量**（对象的属性)，类中定义的方法也成为**成员方法**（对象的行为)

ii.成员变量有默认值（0   ,  0.0  , null)，并不需要初始化

iii.**一个代码文件中，可以写多个class类，但只能一个用public修饰**，**public修饰的类名必须是代码的文件名**

iv.对象与对象之间的数据不会相互影响，**多个对象指向同一个变量时就会相互影响了**

```java
Student s1 = new Student();
s1.name ="FZ";
Student s2=s1;//把s1变量中存储的学生对象地址赋值给了s2变量，即同时指向同一个new出来的Student对象
s2.name ="ZF"//这个时候s1.name的值就是"ZF“
```

v.如果某个对象没有一个变量引用他，则该对象无法操作

``s1=null;``

``s2=null;``

则``s1.name``无法访问name

## 4.this关键字

### this**是一个变量，可以用在方法中，**来拿到当前对象

```java
public class Student{  
	public void pirntThis(){
        System.out.println(this);
    }
}
```

```java
public class Test1 {
    public static void main(String[] args) {
        Student s1 =new Student();
        System.out.println(s1);
        s1.pirntThis();

        Student s2 =new Student();
        System.out.println(s2);
        s2.pirntThis();
    }
}
```

输出结果：

```
tudg.object.Student@1b6d3586
tudg.object.Student@1b6d3586
tudg.object.Student@4554617c
tudg.object.Student@4554617c
```



### this执行原理

* this通过s1（存着new出来的Student对象的地址）找到Student对象，然后通过学生对象（存有类Student的地址）调用类Student中的 printThis 方法。

* Student对象调用方法的时候会把自己对象的地址传给方法里的this接受

也就是说**this可以拿到调他的那个对象**

（会给方法加一个参数）

```java
public void pirntThis(Student this){
        System.out.println(this);
}
```

### this应用

* 解决变量名称冲突问题

```java
public class Student{
   double score;[^1]
	public void printPass(double score[^2]){
    	if(this.score[^1]>score[^2]){
        System.out.println("pass");

    	}else{
        System.out.println("fail");
        }
	}
}
```

```java
Student s3 = new Student();
s3.score =325;
s3.printPass(250);
```

输出结果：pass

## 5.构造器

### i.构造器是一种特殊的方法：名字必须与所在类名一样，不能写返回类型

 构造器也可以**重载**

### ii.构造器的**特点**：

创建对象时，对象会去根据括号里的参数情况来选择对应构造器执行

``Student s =new Student()``

### iii.构造器的**应用**

创建对象时，同时完成对对象成员变量的初始化赋值。（把对象要处理的值给构造器）

```java
public Student1(String name, double score){
    System.out.println("有参数构造器被触发执行了");
    this.name =name;//重要
    this.score=score;//重要
}
```

```java
public class Test {
    public static void main(String[] args) {
        Student1 s1=new Student1();
        s1.name="fz";
        s1.score=100;

        Student1 s2 =new Student1("bozi",99);
    }
}
```

### iv.其他注意事项

* 类在设计的时候，如果不写构造器，java会自动生成一个无参数构造器

* 一旦定义了有参数构造器，java就不会自动生成一个无参数构造器了，**此时建议自己手写一个无参数构造器**

## 6.封装(面向对象的三大特征之一)

用类设计对象处理某一个事物的数据时，应该要把处理的数据，以及处理数据的方法，设计到一个对象中去

i.封装的设计规范：合理隐藏(private)，合理暴露(public)

```java
public class Student2 {
    private double score;//防止瞎赋值
    public void setScore(double score){
        if(score>=0&&score<=100) {
            this.score = score;

        }else{
            System.out.println("数据非法");
        }
    }
    public double getScore(){
        return score;
    }

    public void printPass(){
        System.out.println(score>=60?"Pass":"Fail");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Student2 s1 =new Student2();
        s1.setScore(-99);
        System.out.println(s1.getScore());
    }
}
```

### 实体JavaBean

实体类：一种特殊形式的类，保存某个事物的数据

	i.类中的成员变量都要私有，并且要对外提供相应的getXxx方法，setXxx方法（用来保存数据的java类）
	
	ii.类中必须要有一个公共的无参的构造器

```java
public class Student3 {
    //1.成员变量全部私有并提供get set方法
    private String name;
    private double score;
   // 2.必须为类提供一个无参数构造器

    public Student3() {
    }//无参构造器

    public Student3(String name, double score) {
        this.name = name;
        this.score = score;
    }
	//get set方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Student3 s1 =new Student3();
        s1.setName("fz");
        s1.setScore(99);
        System.out.println(s1.getName());
        System.out.println(s1.getScore());
    }
}
```

#### 应用：实体类只负责数据存取，可以把数据的处理交给其他类来完成，实现数据和数据业务处理相分离

```java
public class Student3Operator {
    private Student3 student;
    //一个有参构造器
    public Student3Operator(Student3 student){
     this.student=student;//重要，把传进来的s1送给上面的的 private Student3 student
    }
    public void printPass(){
        if(student.getScore()>=60){
            System.out.println(student.getName()+"pass");
        }else {
            System.out.println(student.getName()+"fail");
        }
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Student3 s1 =new Student3();
        s1.setName("fz");
        s1.setScore(99);
        System.out.println(s1.getName());
        System.out.println(s1.getScore());

        Student3Operator operator =new Student3Operator(s1);//把s1对象送给操作类
        operator.printPass();
    }
}
```

### 案例:

   i.设计一个类(成员变量要private)保存数据，然后设置get set方法，再设置一个有参构造器（方便赋值），顺便写一个无参构造器

   ii.设计一个操作类，定义一个(类的)数组来处理多个对象，写一个有参构造器用于接受别人送过来的（类的)数组

   iii.准备全部数据

```java
public class Movie {
    private int id;
    private String name;
    private double price;
    private double score;
    private String director;
    private String actor;
    private String info;
    //有参构造器和无参构造器


    public Movie() {
    }

    public Movie(int id, String name, double price, double score, String director, String actor, String info) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.score = score;
        this.director = director;
        this.actor = actor;
        this.info = info;
    }


    //提供get set方法

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public double getScore() {
        return score;
    }

    public String getDirector() {
        return director;
    }

    public String getActor() {
        return actor;
    }

    public String getInfo() {
        return info;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public void setScore(double score) {
        this.score = score;
    }

    public void setDirector(String director) {
        this.director = director;
    }

    public void setActor(String actor) {
        this.actor = actor;
    }

    public void setInfo(String info) {
        this.info = info;
    }
}
```

```java
public class MovieOperator {
    private Movie[] movies;
    //写一个有参构造器
    public MovieOperator(Movie[] movies){
        this.movies=movies;
    }
    //展示系统全部电影信息 movies ={m1,m2,m3,....}
    public void  printAllMovies(){
        System.out.println("-----系统全部电影信息如下-----");
        for (int i = 0; i < movies.length; i++) {
            Movie m =movies[i];
            System.out.println("编号"+m.getId());
            System.out.println("名称"+m.getName());
            System.out.println("价格"+m.getPrice());
            System.out.println("---------------------------------");

        }
    }
    //2.根据电影的编号查询出该电影的详细信息并展示
    public void searchMovieByid(int id){
        for (int i = 0; i < movies.length; i++) {
            Movie m = movies[i];
            if(m.getId()==id){
                System.out.println("该电影详情如下");
                System.out.println("编号"+m.getId());
                System.out.println("名称"+m.getName());
                System.out.println("价格"+m.getPrice());
                System.out.println("得分"+m.getScore());
                System.out.println("导演"+m.getDirector());
                System.out.println("主演"+m.getActor());
                System.out.println("其他信息"+m.getInfo());
                return;
            }
        }
        System.out.println("没有该电影信息");
    }
}
```

```java
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        //1、设计一个电影类
        //2.设计电影操作类
        //3.准备全部电影数据
       Movie[] movies =new Movie[4];
       Movie m1 =new Movie(1,"水门桥",38.9,9.8,"徐克","吴京","12万人想看");
       Movie m2 =new Movie(2,"出拳吧",39,7.8,"唐晓白","田雨","3.5万人想看");
       Movie m3 =new Movie(3,"月球陨落",42,7.9,"罗兰","贝瑞","17.9万人想看");
       Movie m4 =new Movie(4,"一点就到家",35,8.7,"许宏宇","刘昊然","10.8万人想看");
       movies[0]=m1;
       movies[1]=m2;
       movies[2]=m3;
       movies[3]=m4;
       //4.创建一个电影操作类的对象，接收电影数据，并对其进行业务处理

        MovieOperator operator =new MovieOperator(movies);
        operator.printAllMovies();
        operator.searchMovieByid(3);


        Scanner sc =new Scanner(System.in);
        while (true) {//死循环使程序进行
            System.out.println("==电影信息系统==");
            System.out.println("1、查询全部电影信息");
            System.out.println("2、根据id查询某个电影的详细信息展示");
            System.out.println("请输入操作命令：");
            int command =sc.nextInt();
            switch (command){
                case 1:
                    operator.printAllMovies();
                    break;
                case 2:
                    int id = sc.nextInt();
                    operator.searchMovieByid(id);
                    break;
                default:
                    System.out.println("您输入有误");
            }
        }

    }
}
```

## 7.成员变量和局部变量的区别

i.类中位置不同：成员变量(类中，方法外)、局部变量（常见于方法中）

ii.初始化值不同：成员变量(有默认值，不需要初始化赋值)，局部变量(没有默认值，**使用之前必须完成赋值**)

iii.内存位置不同：成员变量（new出来的对象，存在于堆内存），局部变量（栈内存）

iv.作用域不同：成员变量（整个对象），局部变量（在所归属的大括号中）

v.生命周期不同：成员变量（与对象同生共死），局部变量(方法调用而生，方法结束而亡)



## 8.包

包:分门别类管理程序,类似于文件夹，有利于程序管理和维护

**建包的语法格式**:

先建包(idea自动的)再建类

```java
package tudg.javabean;
public class Student{
    
}
```


i.同一个包下的程序，可以直接访问

ii.访问其他包下的程序，必须**导包**才能访问

iii.自己的程序中调用java提供的程序，也需要导包才可以使用（例如Scanner)

   **java.lang**包下的程序不需要导包，可以直接使用

iv.访问多个其他包下的程序，这些程序名又一样的情况下，默认只能导入一个程序，另一个程序必须带包名和类名来访问

## 9.static

* 叫静态，可以修饰成员变量，成员方法。

###  i.成员变量按照有无static修饰，分为两种

* 类变量：**会被类的全部对象共享**

* 实例变量（对象的变量）：**无static**修饰，属于每个对象的

  ```java
  public class Student{
      //类变量
      static String name;  /*有static修饰，属于类，在计算机只有一份，会被类的全部对象共享
      //实例变量（对象的变量）
      int age;
  }
  ```

  

1.对于**类变量**，可以使用**类名.类变量（推荐）**访问

				对象.类变量（不推荐）

2.对于**实例变量**，只能**对象.实例变量**，属于对象，每个对象中都有一份

3.**类变量**：属于类，与类一起加载一次，在内存中只有一份，可以被类和类的所有对象共享。

```java
public class Test {
    public static void main(String[] args) {
        /*static方法的用法和特点*/

        //类名.类变量（推荐）
        Student.name="张三";

        //对象.类变量（不推荐）
        Student s1=new Student();
        s1.name ="李四";

        Student s2=new Student();
        s2.name ="王五";
        System.out.println(s1.name);//  王五
        System.out.println(Student.name);// 王五

        /*2.实例变量的用法*/
        s1.age=20;
        s2.age=28;
        System.out.println(s1.age);//20
        System.out.println(s2.age);//28
    }
}
```

### ii.类变量的应用场景

案例：系统启动后，要求用户类可以记住自己创建了多少个用户对象了

（创建对象实际上就是new一个对象，new一个对象会调用无参构造器）

```java
public class User{
    //类变量
    public static int number;
    
    //构造器
    public User(){
        User.number++;
    }
}
```

代码如下

```java
public class User {
    //类变量一般会用public修饰
    public static int number;
    public User(){
    //在同一个类中，访问自己类的类变量，才可以省略类名不写
        number++;
    }
}
```

```java
public class Test2 {
    public static void main(String[] args) {
        User u1 =new User();
        User u2 =new User();
        User u3 =new User();
        User u4 =new User();

        System.out.println(User.number);//4
    }
}
```

## 10.成员方法的分类

* **类方法**：有static修饰的成员方法，属于类。（**类名.类方法**）一般用来做工具类

* **实例方法**：无static修饰的成员方法，属于对象。（**对象.实例方法**）

  ```java
  public class Student {
      //类方法
      public static void printHelloWorld(){
          System.out.println("Hello World");
          System.out.println("Hello World");
      }
  
      double score;
      //实例方法
      public void printPass(){
  
          System.out.println(score>=60?"pass":"fail");
      }
  }
  ```

  ```java
  public class Test {
      public static void main(String[] args) {
          //类方法的用法
          Student.printHelloWorld();
  
          Student s =new Student();
          s.printHelloWorld();//不推荐
  
          s.printPass();
      }
  }
  ```

## 11.搞懂main方法

* main方法是**类方法**（static修饰）
* main方法如何跑的呢？  >>     java Test ---->**Test.main(...)**

## 12.类方法的应用场景：工具类

类方法最常见的应用场景是做**工具类**

工具类中的方法都是一些类方法，每个方法都是用来完成一个功能的，工具类是给开发人共同使用的

```java
import java.util.Random;

public class MyUtil {
    public static String createCode(int n){
        String code ="";
        String data = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        Random random = new Random();
        for (int i = 0; i < n; i++) {
            int  index = random.nextInt(data.length());
            code += data.charAt(index);
        }
        return code;
    }
}
```

* 实例方法需要创建对象来调用，此时对象只是为了调用方法，对象占内存，这样会浪费内存。

* 类方法，直接用类名调用即可，调用方便，节省内存

### 工具类没有创建对象的需求，建议将工具类的构造器进行私有

```java
private MyUtil(){
    
}
```

对工具类进行私有，因为工具类没有必要创建对象

## 13.static的注意事项

1.类方法中可以直接访问类的成员，但不可以直接访问实例成员。

```java
static String schoolName ;//类变量
double score;//实例变量

//同一个类中访问类成员可以省略类名不写

/*1.类方法中可以直接访问类的成员，不可以直接访问实例成员*/
public static void printHelloWorld(){

    schoolName = "TUDG";
    printHelloWorld2();

    
}
//类方法
public static void printHelloWorld2(){

}
```

2.实例方法中既可以直接访问类成员，也可以直接访问实例成员。

```java
/*2.实例方法中既可以直接访问类成员，也可以直接访问实例成员*/
public void printPass(){
    schoolName="tudg2"; //可以直接访问类变量
    printHelloWorld2(); //可以直接访问类方法
    System.out.println(score);//可以直接访问实例变量
    printPass2(); //可以直接访问实例方法
}
//实例方法
public void printPass2(){

}
```

3.实例方法中可以出现this关键字，类方法中不可以出现this关键字

```java
public void printPass(){
    schoolName="tudg2"; //可以直接访问类变量
    printHelloWorld2(); //可以直接访问类方法
    System.out.println(score);//可以直接访问实例变量
    printPass2(); //可以直接访问实例方法
    System.out.println(this); //this关键字
}
//实例方法
public void printPass2(){

}
```

```java
0.0
tudg.d4_static_attetion.Student@1b6d3586
```



### static应用——代码块

* **代码块**是类的五大成分之一（成员变量、构造器、方法、**代码块**、内部类）

#### 代码块分为两种：

* **静态代码块**：	>格式：static{}

                     	 >特点：**类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次**

								>作用：完成类的初始化，例如：对类变量的初始化赋值。

```Java
public class Student {
    static int number = 80;
    static String schoolname;

    /*静态代码块*/
    static {
        System.out.println("静态代码块执行了~");
        schoolname = "清华大学";                                //初始化赋值
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(Student.number);
        System.out.println(Student.number);
        System.out.println(Student.number);
        System.out.println(Student.schoolname);
    }
}
```

```java
静态代码块执行了~
80
80
80
清华大学
```

* **实例代码块**： >格式: {}

							  >特点: **每次创建对象，执行实例代码块，并在构造器前执行**

	​						 

```java
/*实例代码块*/

{
    
    System.out.println("实例代码块执行了~");
    System.out.printlin("有人创建对象了"+this);
    
}

//实例代码块在构造器前执行
public Student() {
    System.out.println("无参构造器执行了~");
}

public Student(String name) {
    System.out.println("有参数构造器执行了");
}
```

```java
静态代码块执行了~
80
80
80
清华大学
实例代码块执行了~
有人创建了对象，tudg.d5_block.Student@1b6d3586
无参构造器执行了~
实例代码块执行了~
有人创建了对象，tudg.d5_block.Student@4554617c
有参数构造器执行了
```

### static应用——单例设计模式

* 确保一个类只有一个对象
#### 饿汉式单例（拿对象时，对象早就创建好了）

* 把类的构造器私有
* 定义一个类变量记住类的一个对象
* 定义一个类方法，返回对象

```java
public class A {
    //2.定义一个类变量记住类的一个对象
    private static A a = new A();
    //1.必须私有的构造器
    private A() {

    }
    //3.提供一个公共的静态方法，返回类变量
    public static A getObject() {
        return a;
    }
}
```

```java
public class Test1 {
    public static void main(String[] args) {
        A a1 = A.getObject();
        A a2 = A.getObject();
        System.out.println(a1);
        System.out.println(a2);//两次都那同一个对象，说明A类是一个单例类

    }
}
```

```java
tudg.d6_singleInstance.A@1b6d3586
tudg.d6_singleInstance.A@1b6d3586
```

#### 懒汉式单例（拿对象时，才开始创建对象）

**写法：**

* 把类的构造器私有；
* 定义一个类变量用于存储对象；
* 提供一个类方法，保证返回的是同一个对象

```java
public class B {
    //2.定义一个类变量，用于存储这个类的一个对象
    private static B b;
    //1.把类的构造器私有
    private B() {

    }
    //3.定义一个类方法，这个方法要保证第一次调用时才创建一个对象，后面调用时都会用这同一个对象返回
    public static B getInstance() {
       if(b==null){
           System.out.println("第一次创建对象~");
           b=new B();
       }
       return b;
    }
}
```

```java
public class Test2 {
    public static void main(String[] args) {
        B b1 =B.getInstance();//第一次创建对象
        B b2 =B.getInstance();//第二次创建对象
        System.out.println(b1==b2);
    }

}
```

```java
第一次创建对象~
true
```

## 14.继承

java中提供了一个关键字**extends**，用这个关键字，可以让一个类和另一个类建立起父子关系

### 继承的特点

* 子类能继承父类的非私有成员（成员变量、成员方法）

### 继承后对象的创建

* 子类的对象是由子类、父类共同完成的。

  ```java
  package tudg.d7_extends;
  /*父类*/
  public class A {
      //公开成员
      public int i;
      public void print1(){
          System.out.println("print1");
      }
      //私有成员
      private int j;
      private void print2(){
          System.out.println("print2");
      }
  }
  ```

```java
public class B extends A {
    public int k;
    //子类可以继承父类的非私有成员
    public void print3(){

        System.out.println(i);
        print1();

    }
}
```

```java
public class Test {
    public static void main(String[] args) {
    B b =new B();
        System.out.println(b.i);
        System.out.println(b.k);
        b.print1();
        b.print3();

    }
}
```

```java
0
0
print1
0
print1
```

### 继承的好处和应用场景

**1.好处：**

* 减少重复代码的编写


**2.应用场景：**

```java
public class People {
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
}
```

```java
public class Users extends People{
    private String major;

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public void printInfo(){
        System.out.println(getName()+"的专业："+major);
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Users u = new Users();
        u.setName("张三");
        u.setMajor("java");
        System.out.println(u.getName());
        System.out.println(u.getMajor());
        u.printInfo();
    }
}
```

```java
输出结果：//
张三
java
张三的专业：java
```

### 继承的相关注意事项

#### a.权限修饰符

用来限制类中的成员（成员变量、成员方法、构造器、代码块...）能够访问的范围。

|  修饰符   | 在本类中 | 同一个包下的其他类里 | 任意包下的子类里（在子类中访问，在外面创建子类对象不算） | 任意包下的任意类里 |
| :-------: | :------: | :------------------: | :------------------------------------------------------: | :----------------: |
|  private  |    √     |                      |                                                          |                    |
|   缺省    |    √     |          √           |                                                          |                    |
| protected |    √     |          √           |                            √                             |                    |
|  public   |    √     |          √           |                            √                             |         √          |

**private  <  缺省  <   protected   <  public**

```java
package tudg.d9_modifer;

public class Fu {
    //1。私有：只能在本类中访问
    private void privateMethod(){

        System.out.println("私有方法");
    }
    //2.缺省：本类，同一个包下的类
    void defaultMethod(){
        System.out.println("缺省");
    }
    //3.proteced:本类、同一个包下的类、任意包下的子类
    protected void protectedMethod(){
        System.out.println("protected");
    }

    //4.public:本类、同一个包下的类、任意包下的子类、任意包下的任意类
    public void publicMethod(){
        System.out.println("public");
    }

    public void test(){

        privateMethod();
        defaultMethod();
        protectedMethod();
        publicMethod();

    }

}
```

```java
package tudg.d9_modifer;

import javafx.scene.input.DataFormat;

import java.text.DateFormat;

public class Demo {
    public static void main(String[] args) {

        Fu f = new Fu();
        f.defaultMethod();
        f.protectedMethod();
        f.publicMethod();
    }
}
```

```java
package tudg.d10_modifer;

import tudg.d9_modifer.Fu;

public class Zi extends Fu {
    public void test(){
        protectedMethod();
        publicMethod();
    }

}
```

```java
package tudg.d10_modifer;

import tudg.d9_modifer.Fu;

public class Demo2 {
    public static void main(String[] args) {
        Fu f =new Fu();
        f.publicMethod();
    }
}
```

#### b.单继承

Java是**单继承的**，Java中的类**不支持多继承**，但是**支持多层继承**。

```java
public class Test {
    public static void main(String[] args) {


    }
}

class A {}
class B {}

class C extends A {}
/*报错
class C extends A ,B{}*/

class D extends B{}
```

#### c.Object 类

* object 类是 java 所有类的祖宗类。我们写的任何一个类，其实都是objet类的子类或子孙类。

  ```java
  public class Test {
      public static void main(String[] args) {
          A a = new A();
          a.hashCode();
  
      }
  }
  
  class A extends Object{}
  class B {}
  
  class C extends A {}
  /*报错
  class C extends A ,B{}*/
  
  class D extends B{}
  ```

#### d.方法重写

* 当子类觉得父类中的某个方法不好用，或者无法满足自己的需求时，**子类可以重写一个方法名称、参数列表一样的方法**，去覆盖父类的这个方法，这就是方法重写给

* 注意：重写后，方法的访问，Java会遵循**就近原则**。

```java
public class A {
    public void print1(){
        System.out.println("111");
    }

    public void print2(int a,int b){
        System.out.println("22222");
    }
}
```

```JAVA
public class B extends A{
    /*方法重写*/
    public void print1(){
        System.out.println("66666");
    }

    public void print2(int a,int b){
        System.out.println("666");
    }
}
```

```JAVA
public class Test {
    public static void main(String[] args) {
        B b =new B();
        b.print1();
        b.print2(2,3);
    }
}
```

就近原则

```mathematica
66666
666
```

##### 方法重写其他注意事项：

* 重写小技巧：使用**Override注解**，他可以指定java编译器，检查我们方法重写的格式是否正确，代码可读性也会更好
* 子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限（**public > protect > 缺省**）
* 重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小
* 私有方法（private）、静态方法（static）不能被重写，如果重写会报错的。

**声明不变，重新实现**

##### 方法重现的常见应用场景

* 子类重写Object类的toString()方法，以便返回对象的内容

  ```java
  public class Student extends Object{
          private String name;
          private int age;
  
      public Student() {
      }
  
      public Student(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public String getName() {
          return name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
      @Override
      public String toString(){
          return "Student{name:"+name+",age:"+age+"}";
      }
  }
  ```

```java
Student s = new Student("fz",18);
System.out.println(s.toString());
System.out.println(s);//默认调toString，返回地址，可以重写返回内容
```

```java
Student{name:fz,age:18}
Student{name:fz,age:18}
```

#### e.子类中访问其他成员的特点

##### i.子类中访问其他成员（成员变量、成员方法），是依照**就近原则**的。

```java
public class F {
    String name ="父类名称";
    public void print1(){

        System.out.println("==父类的print1方法执行==");

    }
}
```

```java
public class Z extends F{
    String name ="子类名称";
    public void showName(){
        String name ="局部名称";
        System.out.println(name);//局部名称
        System.out.println(this.name);//子类名称
        System.out.println(super.name);//父类名称
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Z z = new Z();
        z.showName();
    }
}
```

```java
局部名称
子类名称
父类名称
```

重写也是就近选择

```java
  @Override

    public void print1() {
        System.out.println("===子类的print1方法执行了====");
    }

    public void showMethod(){
        print1();           //调子类重写的
        super.print1();     //调父类
    }
}
```

在**子类方法访问其他成员**也是依照**就近原则**

*  先子类局部范围找
* 然后子类成员范围找
* 然后父类成员范围找，如果父类范围还没找到则报错

##### ii.super关键字

可以指定访问父类的成员

#### f.子类构造器的特点

* 子类的全部构造器，都会先调用父类的构造器，再执行自己。

```java
public class F {
    public F(){
        System.out.println("==父类F的无参数构造器执行了==");
    }
}
```

```java
public class Z extends F{
    public Z(){
        super();//默认存在的
        System.out.println("====子类Z的无参数构造器执行了");
    }

    public Z(String name){
        super();//默认存在的)
        System.out.println("====子类Z的有参数构造器执行了");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Z z = new Z();
        Z z2 =new Z("z2");
    }
}
```

> ==父类F的无参数构造器执行了==
> ====子类Z的无参数构造器执行了
> ==父类F的无参数构造器执行了==
> ====子类Z的有参数构造器执行了

* 如果**父类没有无参数构造器**，则我们**必须在子类构造器**的第一行手写**super(.....)**，指定去**调用父类的有参数构造器**。

##### i.子类构造器调用父类构造器的应用场景

```java
package tudg.d14_extends_constructor;

public class Test2 {
    public static void main(String[] args) {
        Teacher t =new Teacher("张三",20,"java");
        System.out.println(t.getName()+","+t.getAge()+","+t.getSkill());

    }
}

class Teacher extends People{
    private String skill;
    public Teacher(String name,int age,String skill){
        super(name,age);
        this.skill = skill;
    }

    public String getSkill() {
        return skill;
    }

    public void setSkill(String skill) {
        this.skill = skill;
    }
}
class People{
    private String name;
    private int age;

    public People(){

    }
    public People(String name, int age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

#### g.this(...)调用兄弟构造器

* 任意类的构造器中，是可以通过this(...)去调用该类的其他构造器的。

```java
public class Test3 {
    public static void main(String[] args) {
        Student s1 =new Student("ee",26,"gdut");
        //如果学生没有填写学校，那么学校默认就是genshin
        Student s2 =new Student("ee",26);
        System.out.println(s1.getSchoolName());
        System.out.println(s2.getSchoolName());

    }
}

class Student{
    private String name;
    private int age;
    private String schoolName;

    public Student() {

    }
    public Student(String name, int age) {
        this(name,age,"genshin");
    }

    public Student(String name, int age, String schoolName) {
        this.name = name;
        this.age = age;
        this.schoolName = schoolName;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getSchoolName() {
        return schoolName;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
            this.age = age;
    }

    public void setSchoolName(String schoolName) {
        this.schoolName = schoolName;
    }

}
```

>输出结果如下：
>
>
>
>gdut
>genshin

##### 注意事项

super(...)和this(...)都只能放在构造器的第一行，因此有了this(...)就不能写super(...)了

## 15.多态

* 多态实在**继承/实现**情况下的一种现象，表现为：对象多态、行为多态。

### a.多态的前提

* 有**继承/实现**关系 ；存在父类引用子类对象 ；**存在方法重写**

### b.多态的注意事项

* 多态是对象、行为的多态，java中的属性（成员变量）不谈多态。

```java
package com.tudg.d1_polymophism;
//父类
public class People {
    public void run(){
        System.out.println("people run");
    }
}
```

```java
public class Student extends People{
    @Override
    public void run() {
        System.out.println("学生跑步");
    }
}
```

```java
public class Teacher extends People {
    @Override
    public void run() {
        System.out.println("Teacher run");
    }

}
```

```java
public class Test {
    public static void main(String[] args) {
        People p1 = new Teacher();
        p1.run();//编译看左边，运行看右边
        People p2 = new Student();
        p2.run();
    }
}
```

> Teacher run
> 学生跑步

* 编译看左边，运行看右边

* **对于变量**，编译看左边，运行看左边

```java
public class People {
    public String name = "父类people的名称";
```

```java
public class Student extends People{
    public String name = "子类学生的名称";
```

```java
People p1 = new Teacher();
System.out.println(p1.name);
```

输出结果:

> **父类people的名称**

### c.使用多态的好处

* 在多态形势下，右边对象是解耦合的，更便于扩展和维护。

* 定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强、更便利。


### d.多态下会产生的一个问题：

* 多态下不能使用子类的独有功能。

### e.类型转换

* **自动类型转换：**父类 变量名 = new 子类();                  例如：People p = new Teacher();
* **强制类型转换：**==子类 变量名 =（子类)父类变量==       例如：Teacher  t =(Teacher) p;

#### 强制类型转换的一个注意事项

* 存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错
* 运行时，如果发现对象的真实类型与**强制转换后的类型不同，就会报类型转换一次(ClassCastException)的错误出来**

#### 强转前，Java建议：

* 使用instanceof关键字，判断当前对象的真实类型，再进行强转。

```java
p instanceof  Student
```

代码如下

```java
public class Test {
    public static void main(String[] args) {
        //1多态可以实现解耦合，右边对象可以随时切换，后续业务随之改变
        People p1 =new Student();
        p1.run();
//        p1.test();调布不了子类独有的功能

        //强制类型转换
        Student s1 =(Student)p1;
        s1.test();

        //强制类型转换可能存在的问题:编译阶段有继承或者实现关系就可以强制转换，但是运行时可能出现类型转换异常
        //Teacher t1 =(Teacher)p1; //运行时出现异常:ClassCastException

        if (p1 instanceof Student){
            Student s2 =(Student)p1;
            s2.test();
        }else {
            Teacher t2 =(Teacher)p1;
            t2.teach();
        }
        System.out.println("----------------");
        Student s =new Student();
        //对象回调
        go(s);
        Teacher t  =new Teacher();
        go(t);
    }
        //2.可以使用父类类型的变量作为形参，可以接受一切子类对象
        public static void go(People p1){
            if (p1 instanceof Student){
                Student s =(Student)p1;
                s.test();
            }else if(p1 instanceof  Teacher){
                Teacher t =(Teacher)p1;
                t.teach();
            }
        }
}
```

```java
public class People {
    public String name = "父类people的名称";
    public void run(){
        System.out.println("people run");
    }
}
```

```java
public class Student extends People{
    public String name ="子类Student的名称";

    @Override
    public void run(){
        System.out.println("学生run");
    }
    public void test(){
        System.out.println("学生需要考试");
    }
}
```

```java
public class Teacher extends People{
    public String name ="子类Teacher的名称";
    @Override
    public void run() {
        System.out.println("Teacher run");
    }
    public void teach(){
        System.out.println("Teacher teach");
    }
}
```

## 16.final

* final 关键字是最终的意思，可以修饰（类 、 方法 、 变量）

* 修饰类：该类被称为最终类，特点是不能被继承了。（工具类)

* 修饰方法：该方法被称为最终方法，特点是不能被重写了。

* 修饰变量：改变了只能被赋值一次

  变量：  一、局部变量

  				二、成员变量
  	
  					         1、静态成员变量
  	
  							 2、实例成员变量

### a.final 修饰变量的注意

* final修饰基本类型的变量，变量存储的**数据**不能被改变

* final修饰引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是可以被改变的。

```java
public class Test {
    /*常量：public static final 修饰的成员变量，建议名称全部大写，多个单词下划线连接*/
    public static final String SCHOOL_NAME = "GDUT";
    public static void main(String[] args) {
        //3.final可以修饰变量:总规则：有且仅能赋值一次
        final int a;
        a = 10;
//        a = 20;      第二次赋值，出错了
        final double r =3.14;
//        r=0.1        第二次赋值，出错了

        final int[] arr = {11,22,33};
        arr[0]=44;    //改数据可以
//        arr =null;   地址名不能动




       /*
    private final String name = "张三"
       Test t =new Test();
        t.name = "李四";   一般不用final修饰实例变量，这种用法没有意义*/
    }

    public static void buy(final double z){
    //        z=10;第二次赋值，报错

    }
}

//1.final修饰类，类不能被继承了
final class A{

}
/*
class B extends A{

}*/

//2.final修饰方法，方法不能被重写
class C{
    public final void test(){

    }
}

class D extends C{
//    @Override
//    public void test(){
//
//    }
}
```

### b.常量

* 使用**static final修饰的成员变量就被称为常量**；

* 作用：**通常用于记录系统的配置信息**。

常量的命名规范跟C语言的宏定义一样

* 程序编译后，常量会被**“宏替换”**：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的。

## 17.抽象类

### a.认识抽象类

* **abstract** ，抽象**(不能实例化，即不能创建对象)**的意思，可以用它修饰**类、成员方法**。

* **abstract**修饰类，这个类就是抽象类；修饰方法，这个方法就是抽象方法

#### i.抽象类的注意事项、特点

*  抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类

* 类该有的成员（成员变量、方法、构造器）抽象类都可以有。

* **抽象类最主要的特点：**抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现

  一个类继承抽象类，必须重写玩抽象类的全部抽象方法，否则这个类也必须定义成抽象类。

* 一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。

  ```java
  public abstract class A {
      public String name;
      public static String schoolName;
      public A(String name){
  
      }
      public A(){
  
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public static String getSchoolName() {
          return schoolName;
      }
  
      public static void setSchoolName(String schoolName) {
          A.schoolName = schoolName;
      }
  
      //抽象方法：必须用abstract，只有方法签名，一定不能有方法体
      public abstract  void run();
  
  
  }
  ```

```java
public class Test {
    public static void main(String[] args) {
       /* 1.抽象类不能创建对象
        A a =new A();
        a.run();*/
    }
}
```

```java
//一个类继承了抽象类，必须重写完抽象类的全部抽象方法，否则自己也要是抽象类
public abstract class B extends A{
    
}
```

### b.抽象类的好处(√)

* 父类知道每个子类要做某个行为，**但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类重写实现，==我们设计这样的抽象类，就是为了更好的支持多态==**

```java
public abstract class Animal {
    private String name;

    public abstract void cry();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
public class Cat extends Animal{
        @Override
    public void cry() {
       System.out.println(getName()+"喵喵喵");
    }
}
```

```java
public class Dog extends Animal{
    @Override
    public void cry(){
        System.out.println(getName()+"汪汪叫");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Animal a = new Cat();
        a.setName("小花");
        a.cry();
        Animal a2 = new Dog();
        a2.setName("小黑");
        a2.cry();
    }
}
```

### c.抽象类的常见应用场景：模板方法设计模式

* 解决方法中存在重复代码的问题

#### i.模板方法设计模式的写法

1.定义一个抽象类

2.在里面定义2个方法

* **一个是模板方法：把相同代码放里面去**
* 一个是抽象方法：**具体实现交给子类完成**

3.建议使用    **final**   关键字修饰模板方法

* 防止子类重写模板方法使得模板方法失效

```java
public abstract  class People {
    public final void write(){
        System.out.println("\t\t\t\t《genshin》");
        System.out.println(writeMain());
        System.out.println("原神，启动！");
    }

    public abstract String writeMain();

}
```

```java
public class Student extends People{
    @Override
    public String writeMain() {
        return "学生启动";
    }
}
```

```java
public class Teacher extends People{
   @Override
   public String writeMain() {
       return "老师启动";
   }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Teacher t = new Teacher();
        t.write();/*输出:          《genshin》
                        老师启动
                        原神，启动！*/


        Student s =new Student();
        s.write();/*输出:          《genshin》
                        学生启动
                        原神，启动！*/
    }
}
```

## 18.接口

### a.认识接口

* Java提供了一个关键字 **interface** ，用这个关键字我们可以定义出一个特殊的结构：接口。

		接口中定义的成员变量，java默认是**常量**，需要**赋初始值**；
		
		成员方法默认是抽象方法；
		
		接口也不能创建对象；

```java
public interface A {
    //成员变量（常量）
     String SCHOOL_NAME = "清华大学";//接口中定义的变量，java默认是常量，需要赋初始值


    //成员方法（抽象方法）
     void test();
}
```

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(A.SCHOOL_NAME);//直接访问
        /*A a =new A();    接口是抽象的，不能实例化*/
    }
}
```

* 接口不能创建对象；接口是用来被类      **实现（implements）**  的，实现接口的类称为**实现类。**

* **一个类可以实现多个接口（接口可以理解成干爹）**，实现类实现多个接口，**必须重写全部接口的全部抽象方法**，否则实现类需要**定义成抽象类**。

```java
public interface B {
    void testb1();
    void testb2();
}
```

```java
public interface C {
    void testc1();
    void testc2();
}
```

```java
//实现类
public class D implements B,C{

    @Override
    public void testb1() {

    }

    @Override
    public void testb2() {

    }

    @Override
    public void testc1() {

    }

    @Override
    public void testc2() {

    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(A.SCHOOL_NAME);
        /*A a =new A();    接口是抽象的，不能实例化*/
        D d =new D();
    }
}
```

### b.接口的好处

* 弥补了类单继承的不足，一个类同时可以实现多个接口。
* 让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现。

```java
package com.tudg.d6_interface2;

public class Test {
    public static void main(String[] args) {
        Singer s =new A();
        s.sing();
        Driver d = new A();
        d.dirve();
        
        Singer s1 = new B();//也可以改成 Singer s1 = new A();  灵活切换接口
        s1.sing();
    }
}

class B implements Singer{
    @Override
    public void sing() {

    }
}
class A extends Student implements Student,Driver,Singer{
    @Override
    public void dirve() {
        
    }

    @Override
    public void sing() {

    }
}

class Student{
    
}

interface Driver{
    void dirve();
}

interface Singer{
    void sing();
}
```

### c.接口综合案例（面向接口编程）

需求：设计一个班级学生的信息管理模块：学生的数据有：姓名、性别、成绩

功能1：要求打印出全班学生的信息；

功能2：要求打印全班学生的平均成绩。

-------------------------------

实现上述功能**有多套方案**

方案1：能打印出班级全部学生的信息；能打印出班级全部学生的平均分。

方案2：能打印出班级全部学生的信息**（包含男女人数）**；能打印出班级全部学生的平均分**（去掉最高分和最低分）**

```java
public class Student {
    private String name;
    private char sex;
    private double score;
    public Student(){
    }
    public Student(String name, char sex, double score) {
        this.name = name;
        this.sex = sex;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public char getSex() {
        return sex;
    }

    public double getScore() {
        return score;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public void setScore(double score) {
        this.score = score;
    }
}
```

```java
public class ClassManager {
    private ArrayList <Student> students =new ArrayList<>();
    private StudentOperator studentOperator = new StudentOperatorImpl2();
    public ClassManager(){
        students.add(new Student("张三",'男',99));
        students.add(new Student("李四",'男',88));
        students.add(new Student("王五",'女',77));
        students.add(new Student("赵六",'女',66));
    }

    /*打印全班全部学生的信息*/
    public void printInfo(){
        studentOperator.printAllinfo(students);
    }

    /*打印全班全部学生的平均分*/
    public void printScore(){
        studentOperator.printAverageScore(students);
    }
}
```

```java
public interface StudentOperator {
    void printAllinfo(ArrayList<Student> students);
    void printAverageScore(ArrayList<Student> students);
}
```

```java
public class StudentOperatorImpl1 implements StudentOperator{
    @Override
    public void printAllinfo(ArrayList<Student> students) {
        System.out.println("--------全班全部学生信息如下-------");
        for (int i = 0; i < students.size(); i++) {
            Student s = students.get(i);
            System.out.println("姓名："+s.getName());
            System.out.println("性别：："+s.getSex());
            System.out.println("成绩：："+s.getScore());
        }
        System.out.println("---------------");
    }

    @Override
    public void printAverageScore(ArrayList<Student> students) {
        double allScore =0.0;
        for (int i = 0; i < students.size(); i++) {
            Student s =students.get(i);
            allScore += s.getScore();
        }
        System.out.println("全班平均分："+allScore/students.size() + "分");
    }
}
```

```java
public class StudentOperatorImpl2 implements StudentOperator{
    @Override
    public void printAllinfo(ArrayList<Student> students) {
        System.out.println("--------全班全部学生信息如下-------");
        int count1 =0;
        int count2 =0;
        for (int i = 0; i < students.size(); i++) {
            Student s = students.get(i);
            System.out.println("姓名：" + s.getName());
            System.out.println("性别：：" + s.getSex());
            System.out.println("成绩：：" + s.getScore());
            if (s.getSex() == '男') {
                count1++;
            } else {
                count2++;
            }
            System.out.println("------------------------");
        }
            System.out.println("男生人数："+count1);
            System.out.println("女生人数："+count2);
            System.out.println("班级总人数是："+students.size());
            System.out.println("---------------");

    }

    @Override
    public void printAverageScore(ArrayList<Student> students) {
        double allScore =0.0;
        double max =students.get(0).getScore();
        double min =students.get(0).getScore();
        for (int i = 0; i < students.size(); i++) {
            Student s =students.get(i);
            if (s.getScore()>max) max =s.getScore();
            if (s.getScore()<min) min =s.getScore();
            allScore += s.getScore();
        }
        System.out.println("---------------");
        System.out.println("学生的最高分是："+max);
        System.out.println("学生的最低分是："+min);
        System.out.println("全班平均分："+(allScore-max-min)/(students.size()-2) + "分");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        ClassManager clazz = new ClassManager();
        clazz.printInfo();
        clazz.printScore();
    }
}
```

### d.JDK8开始，接口中新增的三种方法

接口中的方法默认  **public** 修饰(供别人调用)

* 默认方法：使用  **default** 修饰，使用实现类的对象调用

* 静态方法：**static** 修饰，必须用当前接口名调用

  

```java
public interface A {
    /**
     * 1。默认方法：必须使用default关键字修饰，默认会public修饰
     * 实例方法：对象的方法，必须使用实现类的对象来访问
     */
    public default void test1(){
        System.out.println("==默认方法==");
        /*test2();*/
    }

    /**
     * 2。私有方法：必须使用private修饰，私有方法只能在接口中调用(JDK9开始支持)
     *    实例方法：对象的方法，必须使用实现类的对象来访问
     *    private void test2(){
     *        System.out.println("==私有方法==");
     *   }
     */

    /**
     * 3。静态方法：必须使用static修饰，静态方法只能通过接口名调用
     */
    public static void test3(){
        System.out.println("==静态方法==");
    }
    
//    void test4();
    default void  test5() {

    }
}
```

```java
public class B implements A{

}
```

```java
public class Test {
    public static void main(String[] args) {
        B b =new B();
        b.test1();//默认方法的使用

        A.test3();//静态方法的使用
    }
}
```

### e.接口的多继承、注意事项

 #### i.接口的多继承

* 一个接口可以同时继承多个接口

**作用：**

* 便于实现类去实现。

  ```java
  public class Test {
      public static void main(String[] args) {
  
      }
  }
  
  interface A{
      void test1();
  }
  interface B{
      void test2();
  }
  interface C{}
  /*接口是多继承的*/
  interface D extends A,B,C{
  
  }
  
  class E implements D{
  
      @Override
      public void test1() {
  
      }
  
      @Override
      public void test2() {
  
      }
  }
  ```

#### ii.接口的其他注意事项

1.一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承

2.一个类实现多个接口，如果多个接口中存在方法签名冲突，则此时不支持多实现

3.一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会优先用父类的

4.一个类实现了多个接口，多个接口中存在同名的默认方法，这个类重写该方法即可

```java
package com.tudg.d9_interface_attention;

public class Test2 {
    public static void main(String[] args) {
        Zi z = new Zi();
        z.run();//===父类的run方法执行了==
    }

}


//    1.一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承
interface I{
    void test1();
}
interface J{
    String test1();
}
/*
interface K extends I,J{}  报错，方法签名冲突了，不知道重写哪个test1方法*/



//    2.一个类实现多个接口，如果多个接口中存在方法签名冲突，则此时不支持多实现
/*
class E implements I,J{
    @Override
    public void test1() {

    }

    @Override
    public String test1() {
        return null;
    }
}*   报错，不知道调哪一个test1/
 */



//    3.一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会优先用父类的
class Fu{
    public void run(){
        System.out.println("===父类的run方法执行了===");
    }
}
interface IT{
    default void run(){
        System.out.println("===接口IT中的run方法执行了===");
    }
}

class Zi extends Fu implements IT{

}



//    4.一个类实现了多个接口，多个接口中存在同名的默认方法，这个类重写该方法即可
interface IT1{
    default void test(){
        System.out.println("IT1");
    }
}

interface IT2{
    default void test(){
        System.out.println("IT2");
    }
}

class N implements IT1,IT2{

    @Override
    public void test() {
        System.out.println("自己的");
    }
}
```

## 19.内部类

### a.内部类概述、成员内部类（了解）

* 内部类是类中的五大成分之一（成员变量、方法、构造器、**内部类**、代码块），**如果一个类定义在另一个类的内部，这个类就是内部类**
* 场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类

#### i.内部类的四种形式

1.成员内部类

* 类中的一个普通成员
* JDK16之前，成员内部类中不能定义静态成员，JDK16开始也可以定义静态成员

```java
public class Outer {
    private int age = 99;
    public static String a;
    public class Inner{
        private  String name ;
       /* public static String schoolName;  JDK16开始才可以定义静态成员变量*/

        private int age = 88;
        public void test(){
            System.out.println(age);
            System.out.println(a);
            int age =66;
            System.out.println(age);//66
            System.out.println(this.age);//88
            System.out.println(Outer.this.age);//99
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Outer.Inner in =new Outer().new Inner();//创建对象的格式
        in.test();
    }
}
```

* 成员内部类的实例方法中，**可以直接访问外部类的实例成员、静态成员**（跟实例方法类似）
* 可以在成员内部类的实例方法中，拿到当前外部类对象，**格式是：  外部类名.this**。

2.静态内部类

* 有  **static** 修饰的内部类，属于外部类自己持有

* 静态内部类中访问外部类成员的特点：

  ①可以直接访问外部类的静态成员，不可以直接访问外部类的实例成员

  ```java
  public class Outer {
      private int age;
      public static String schoolName;
      public static class Inner{
          private String name;
          public static int a;
          public void test(){
              System.out.println(schoolName);
  //          System.out.println(age);  必须用外部类的对象来访问
          }
          public String getName() {
              return name;
          }
  
          public void setName(String name) {
              this.name = name;
          }
  
          public static int getA() {
              return a;
          }
  
          public static void setA(int a) {
              Inner.a = a;
          }
      }
      
      public static void test2(){
          System.out.println(schoolName);
  //        System.out.println(age);  age是实例变量，是对象的成员变量，不能直接访问
      }
  }
  ```

**创建对象格式：**外部类名.内部类名     对象名  =new 外部类.内部类(...)

```java
public class Test {
    public static void main(String[] args) {
        Outer.Inner in = new Outer.Inner();
        in.test();
    }
}
```

3.局部内部类（**鸡肋**）

* 定义在方法中、代码块中、构造器等执行体中。

##### 4.认识**匿名内部类(重点)**

* 一种特殊的**局部内部类**；所谓匿名，就是程序员**不需要为这个类声明名字**

```java
new 类或接口 (参数值...){
    类体（一般是方法重写）
};        
```

把这个匿名内部类编译成一个**子类**，然后会立即创建出一个子类对象出来

* **特点：**匿名内部类本质就是一个子类，并会立即创建出一个子类对象。
* **作用：**用于更方便的创建一个子类对象。

##### 5.匿名内部类在开发中的使用场景

###### i.overview

* 　<font color='red'> 通常作为一个参数传输给方法。 </font>

```java
public class Test2 {
    public static void main(String[] args) {
        go(new Swimming(){
            @Override
            public void swim() {
                System.out.println("狗游泳飞快");
            }
        });
    }

    //设计一个方法，可以接受Swimming接口的一切实现类对象进来参加游泳比赛
    public static void go(Swimming s){
        System.out.println("比赛开始----------");
        s.swim();
    }
}


//猫和狗都要参加游泳比赛
interface Swimming{
    void swim();
}
```

运行结果：

> 比赛开始----------
> 狗游泳飞快

###### ii.GUI编程

```java
package com.tudg.d12_inner_class5;

import javax.swing.*;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * @author fz
 */
public class Test {
    public static void main(String[] args) {
        //GUI编程
        //1、创建窗口
        JFrame win = new JFrame("登录界面");
        JPanel panel = new JPanel();
        win.add(panel);

        JButton btn = new JButton("登录");
        panel.add(btn);

        //给按钮绑定单击事件监听器。
     /*   btn.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                JOptionPane.showMessageDialog(win, "登录成功");
            }
        });*/
        //核心目的是简化代码
        btn.addActionListener(e -> JOptionPane.showMessageDialog(win, "登录成功"));
        win.setSize(400, 400);
        win.setLocationRelativeTo(null);
        win.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        win.setVisible(true);
    }
}
```

## 20.枚举

### a.概述

* 枚举是一种特殊类。

### b.枚举的格式

```java
修饰符(例如public) enum 枚举类名(例如A){
    X, Y, Z;
    其他成员...
}
```

#### 注意：

* 枚举类中的第一行，只能写一些合法的标识符（名称），多个名称用逗号隔开。
* <font color='red'>这些名称，本质是常量，每个常量都会记住枚举类的一个对象。</font>

```java
public enum A {
    //第一行罗列枚举对象的名字
    X , Y, Z;
    private String name;



    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        A a1 =A.X;
        System.out.println(a1);//输出X
    }
}
```

* <font color='red'>枚举类的第一行只能罗列一些名称，这些名称是常量，并且每个常量记住的都是枚举类的一个对象。</font>

* 枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象。

* 枚举都是最终类，不能被继承。

* 枚举类中，从第二行开始，可以定义类的其他各种成员。

* 编译器为枚举类新增了几个方法，并且枚举类都是继承；java.lang.Enum 类的，从enum类也会继承到一些方法。

  反编译如下：

```java
Compiled from "A.java"
public final class A extends java.lang.Enum<A>{
    public static final A X =new A();
    public static final A Y =new A();
    public static final A Z =new A();
    
    public static A[] values();//拿到当前所有枚举对象，放到一个 类 型数组给我们
    public static A valueOf(java.lang.String);
}    
```

```java
public class Test {
    public static void main(String[] args) {
        A a1 =A.X;
        System.out.println(a1);//输出X

       /* 枚举类的构造器私有，不能对外创建对象
        A a =new A();*/

        //枚举类的第一行都是常量，他记住的是枚举类的对象
        A a2 =A.Y;

        //枚举类提供一个额外的API
        A[] as = A.values(); //拿到全部对象
        A a3 = A.valueOf("Y");//拿到对象        ---> Y
        System.out.println(a3.name()); //拿到对象的名字     ---> Y
        System.out.println(a3.ordinal());//拿到对象的索引;  ---> 1
		
        //抽象枚举
        B y =B.Y;
        y.go();
    }
}
```

```java
public enum B {
    X(){
        @Override

        public void go() {

        }
    },Y("张三"){
        @Override

        public void go() {
            System.out.println(getName()+"在走~");
        }
    };
    private String name;

    B() {
    }

    B(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public abstract void go();
}
```

* 抽象枚举：枚举对象调无参构造器（private），重写抽象方法。

### c.枚举实现单例设计模式

```java
public enum C {
    X;      //单例
}
```

### d.枚举的应用场景

* 用来表示一组信息，然后作为参数进行传输。

**选择定义一个一个的常量来表示一组信息，并作为参数传输**

* 参数值不受约束

**选择定义枚举表示一组信息，并作为参数传输**

* 代码可读性好，参数值得到了约束，对使用者更友好

```java
public class Test {
    public static void main(String[] args) {
        check(Constant2.BOY);
    }

    public static void check(Constant2 sex){
        switch (sex){
            case BOY:
                System.out.println("展示一些游戏信息~");
                break;
            case GIRL:
                System.out.println("展示女频小说~");
                break;
        }
    }
}
```

```java
public enum Constant2 {
    BOY,GIRL;
}
```

## 21.泛型

* 定义类、接口、方法时，<font color="red">同时声明了一个或者多个类型变量（如:``<E>``)</font>,称为泛型类、泛型接口、泛型方法，他们统称为泛型。

```java
public class ArrayList<E>{
    ...
}
```

作用：泛型提供了在编译阶段所能操作的数据类型，并自动进行检查的能力！**避免强制类型转换及其可能出现的异常**

### a.泛型的本质

把具体的数据类型作为参数传递给类型变量。

```java
ArrayList<String> list1 = new ArrayList<>();
list1.add("aaa");
list1.add("bbb");
list1.add("ccc");
for (int i = 0; i < list1.size(); i++) {
    System.out.println(list1.get(i));
}

ArrayList<Cat> list2 = new ArrayList<>();
list2.add(new Cat());
```

### b.泛型类

```java
修饰符 class 类名<类型变量，类型变量,...>{
    
}
```

```java
public class MyArrayList<E> {
    private Object[] arr = new Object[10];
    private int size = 0; //记录当前位置的

    public boolean add(E e) {
        arr[size++] = e;
        return true;
    }
    public E get(int index) {
        return (E)arr[index];
    }
}
```

```java
public class MyClass2 <E,T>{
    public void put(E e,T t){

    }
}
```

```java
public class MyClass3 <E extends Animal>{

}
```

```java
public class Test {
    public static void main(String[] args) {
        MyArrayList <String>list = new MyArrayList<>();
        list.add("aaa");
        System.out.println(list.get(1));

        MyClass2<String, String> c2 = new MyClass2<>();
        c2.put("aaa", "bbb");
        

        MyClass3<Animal> c4 = new MyClass3<>();
        MyClass3<Dog> c5 = new MyClass3<>();
        MyClass3<Cat> c6 = new MyClass3<>();
    }
}
```

### c.泛型接口

```java
修饰符 interface 接口名<类型变量, 类型变量,...>{
    
}
```

```
//场景：系统需要处理学生和老师数据，需要提供两个功能，一个是保存对象数据，一个是根据对象名称查询数据
//定义一个接口，规定功能
```

```java
public interface Data<T> {
    void add(T t);
    ArrayList<T> getByName(String name);
}
```

```java
public class TeacherData implements Data<Teacher>{
    @Override
    public void add(Teacher teacher) {

    }

    @Override
    public ArrayList<Teacher> getByName(String name) {
        return null;
    }
}
```

```java
public class StudentData implements Data<Student>{

    @Override
    public void add(Student student) {
        
    }

    @Override
    public ArrayList<Student> getByName(String name) {
        return null;
    }
}

```

可以继承 **extends**

```java
public interface Data<T extends Animal> {
    void add(T t);
    ArrayList<T> getByName(String name);
}
```

```java
public class StudentData implements Data<Cat>{

    @Override
    public void add(Cat cat) {

    }

    @Override
    public ArrayList<Cat> getByName(String name) {
        return null;
    }
```

### d.泛型方法

```java
修饰符<类型变量,类型变量,...> 返回值类型 方法名（形参列表）{

}    
```

```java
public static <T> void test(T t){
    
}
```

```java
        String s = test("java");
        System.out.println(s);
        test(new Dog());

        //需求：所有汽车可以一起参加比赛
        ArrayList<Car> cars = new ArrayList<>();
        cars.add(new BMW());
        cars.add(new BENZ());
        go(cars);

        ArrayList<BMW> bmws = new ArrayList<>();
        bmws.add(new BMW());
        bmws.add(new BMW());
        go(bmws);

        ArrayList<BENZ> benzs = new ArrayList<>();
        benzs.add(new BENZ());
        benzs.add(new BENZ());
        go(benzs);

       /* ArrayList<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog());
        dogs.add(new Dog());
        go(dogs);   没有继承Car类*/
    }
    public static<T extends Car> void go(ArrayList<T> cars){

    }

    //泛型方法
    public static <T> T test(T t){
        return t;
    }
}
```

#### ? 通配符

可以在使用泛型时可以代表一切类型

```java
public static void go(ArrayList<? extends Car> cars){
    
}
```

`? extends Car(上限)`

`？super Car(下限)`  送的对象必须是  Car  或者  Car  的父类

### e.泛型的注意事项

* 泛型是工作在编译阶段的，一旦程序编译成 class 文件，class 文件中就不存在泛型了，这就是**泛型擦除**

  `ArrayList<String> list = new ArrayList<>();`

  反编译后是 Object 类型,即`ArrayList list = new ArrayList(); ` 会进行强转

* 泛型不支持基本数据类型，只能支持对象类型（引用数据类型）

不支持`ArrayList<double> list = new ArrayList<>();`

解决方法

```java
ArrayList<Integer> list2 = new ArrayList<>();
list2.add(111);
ArrayList<Double> list3 = new ArrayList<>();
list3.add(1.1);
```